#compdef project

# vim:ft=sh:

# project completion
# --------------------------------------------------------------------------------------------------

# Description
# -----------
 # Makes my project function a little smarter
# --------------------------------------------------------------------------------------------------
# Authors
# -------
# Filipe Kiss <eu@filipekiss.com.br> http://github.com/filipekiss
# --------------------------------------------------------------------------------------------------


__project_describe_commands() {
    local -a command_list
    command_list=('create:create a new project' 'clone:clone a project')
    _describe -t commands "Commands" command_list
}

__project_argument_generic() {
    case $words[1] in
        (create)
            _arguments \
                "1:namespace:__project_describe_namespace" && ret=0
            ;;
        (clone)
            _arguments \
                "1:namespace:__project_describe_namespace" && ret=0
            ;;
    esac
    return $ret
}

__project_describe_namespace() {
    local namespaces title
    _description=($(_list_available_namespaces))
    _describe -t namespace "Project Namespace" _description
}

__project_describe_projects() {
    _description=($(_list_available_projects $words[2]))
    _project_path=$(_get_project_path ${words[2]})
    _describe -t project "Listing projects ${_project_path/#${HOME}/~}" _description
}


_list_available_namespaces() {
    local home_namespaces project_namespaces _has_projects_folder _description
    _description=()
    [[ -z $PROJECTS ]] && PROJECTS=$HOME

    if [[ -n $PROJECTS ]]; then
        project_namespaces=($(find ${PROJECTS}/* -maxdepth 0 -type d -not -path '*/\.*' -printf '%f\n'))
        for namespace in $project_namespaces; do
            [[ -n $_has_projects_folder ]] && prefix="projects/"
            _description+=("${namespace}:${PROJECTS}/${namespace}")
        done;
    fi

    echo ${(iF)_description}
}

_list_available_projects() {
    local _selected_namespace _description
    _selected_namespace="$1"
    _description=()
    NAMESPACE_PATH=$(_get_project_path $_selected_namespace)
    _projects_available=($(find ${NAMESPACE_PATH}/* -maxdepth 0 -type d))
    for project in $_projects_available; do
        _description+=("${project:t}:${project/#${HOME}/~}")
    done;
    echo ${(iF)_description}
}

_get_project_path() {
    local NAMESPACE_PATH _selected_namespace
    _selected_namespace="$1"
    [[ -d ${PROJECTS}/${_selected_namespace} ]] && NAMESPACE_PATH=${PROJECTS}/${_selected_namespace} || NAMESPACE_PATH=${HOME}/${_selected_namespace}
    echo $NAMESPACE_PATH
}


_project() {
    local curcontext="$curcontext" state line help="-h --help"
    integer ret=1
    typeset -A opt_args

    _arguments \
        "($help -): :->command" \
        "($help -)*:: :->argument" && ret=0

    case $state in
        (command)
            __project_describe_commands && ret=0
            ;;
        (argument)
            curcontext=${curcontext%:*:*}:${completion_name}-$words[1]:
            __project_argument_generic $words[1] && ret=0
            ;;
    esac

    return ret

}

_project "$@"
