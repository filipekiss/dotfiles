#!/usr/bin/env zsh

! has_dotfiles_function > /dev/null 2>&1 && [[ -e $HOME/.dotfiles/bin/dotfiles ]] && source $HOME/.dotfiles/bin/dotfiles "source"
! has_dotfiles_function > /dev/null 2>&1 && echo "Something went wrong. Try again" && exit 1

function main() {
  local config="$1"
  local action="config"
  [[ $# -gt 0 ]] && shift
  case $config in
    "unconfig" )
        action="unconfig"
        config="$1"
        [[ $# -gt 0 ]] && shift
      ;;
    "clean" )
        action="clean"
        config="$1"
        [[ $# -gt 0 ]] && shift
      ;;
  esac
  local files=($@)
  [[ $action == "config" ]] && make_config $config $files
  [[ $action == "unconfig" ]] && undo_config $config $files
  [[ $action == "clean" ]] && clean_config $config
}


function clean_config() {
  local config_to_clean="$1"
  local config_path
  config_path=${DOTFILES}/config/${config_to_clean}
  echo $config_path
}

function undo_config() {
  local config="$1"
  [[ $# -gt 0 ]] && shift
  local files=($@)
  local config_location=${DOTFILES}/config/${config}
  if [[ ! -e ${config_location} ]]; then
    e_error "Config ${config} doesn't exists. Please, check your configs and try again!"
    exit 1
  fi
  if [[ -z ${files} ]]; then
    e_info "No files specified. If you want to remove ALL config, run\n${PURPLE}find ${config_location%/} -type f -print0 | xargs -0 config unconfig ${config}"
    exit 0
  fi
  for file in ${files}; do
    [[ ! -e ${file} ]] && file=${config_location}/${file}
    if [[ -d ${file} ]]; then
      e_info "This is a folder. Try\n${PURPLE}find ${file%/} -type f -print0 | xargs -0 config unconfig ${config}"
      exit 0
    fi
    local finalname=${file#${config_location}/}
    finalname=${finalname#${HOME}/}
    local source=${config_location}/${finalname}
    local dest=${HOME}/${finalname}
    local fileonly=$(basename ${file})
    local dest_folder=${dest%$fileonly}
    if [[ -e ${dest} ]] && [[ ! -L ${dest} ]]; then
      e_info "The file ${PURPLE}$(basename ${file})${RESET} already exists at ${YELLOW}${dest}${RESET}. ${RED}Skipping...${RESET}"
      continue
    fi
    mkdir -p ${dest_folder}
    e_info "Moving ${PURPLE}$(basename ${file})${RESET} to ${YELLOW}${dest}${RESET}"
    mv "${source}" "${dest}"
  done
  exit 0
}

function make_config() {
  local config="$1"
  [[ $# -gt 0 ]] && shift
  local files=($@)
  [[ -z $files ]] && e_info "USAGE: ${PURPLE}config ${YELLOW}<config> ${GREEN}<files to add>" && exit 0
  local config_location=${DOTFILES}/config/${config}
  if [[ ! -e ${config_location} ]]; then
    e_info "Creating config at ${config_location}"
  fi
  for file in ${files}; do
    if [[ -L ${file} ]]; then
      local realfile=$(realpath -e $file)
      e_info "${PURPLE}$(basename ${file})${RESET} is a symbolic link to ${PURPLE}${realfile}${RESET}."
      file=$realfile
    fi
    if [[ -d ${file} ]]; then
      e_info "This is a folder. Try\n ${PURPLE}find ${file%/} -type f -print0 | xargs -0 config ${config}"
      exit 0
    fi
    if ! validate_path ${file}; then
      e_info "${PURPLE}config${RESET} is meant for files located below your home folder. ${file} is outside your home folder"
      continue
    fi
    local finalname=${file#${config_location}/}
    finalname=${finalname#${HOME}/}
    local source=${HOME}/${finalname}
    local dest=${config_location}/${finalname}
    local fileonly=$(basename ${file})
    local dest_folder=${dest%$fileonly}
    if [[ -e ${dest} ]]; then
      e_info "The file ${PURPLE}$(basename ${file})${RESET} already exists at ${YELLOW}${dest}${RESET}. ${RED}Skipping...${RESET}"
      continue
    fi
    [[ ! -e ${source} ]] && e_error "${RESET}The file ${source} doesn't exists" && continue
    mkdir -p ${dest_folder}
    e_info "Copying ${PURPLE}$(basename ${file})${RESET} to ${YELLOW}${config}${RESET}"
    cp "${source}" "${dest}"
    e_info "Linking ${PURPLE}$(basename ${file})${RESET} back from ${YELLOW}${config}${RESET}"
    rm -f ${source}
    ln -sf "${dest}" "${source}"
  done
  exit 0
}

function validate_path() {
  local file_path="$1"
  [[ ${file_path#$HOME} == ${file_path} ]] && return 1 || return 0
}


main $@
