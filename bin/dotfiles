#!/usr/bin/env bash
# Log functions
tput sgr0

RED=$(tput setaf 1)
YELLOW=$(tput setaf 3)
GREEN=$(tput setaf 2)
PURPLE=$(tput setaf 5)
BLUE=$(tput setaf 4)
WHITE=$(tput setaf 7)
BOLD=$(tput bold)
RESET=$(tput sgr0)

LOG_STATUS_SUCCESS="✔"
LOG_STATUS_ERROR="✖"
LOG_STATUS_INFO="➜"

e_header()   { e_line && e_line "${1} ==" "${BOLD}" "==" "${BOLD}"; }
e_line() { [[ $LINE_BREAK != "" ]] && LINE_BREAK="\n"; printf "${4} %b${RESET} ${2}%b${RESET}${LINE_BREAK}" "${3}" "${1}"; }
e_success() { e_line "$1" "${GREEN}" "${LOG_STATUS_SUCCESS}" "${GREEN}"; }
e_error() { e_line "$1" "${RED}" "${LOG_STATUS_ERROR}" "${RED}"; }
e_info() { e_line "$1" "" "${LOG_STATUS_INFO}" "${BLUE}"; }
e_reset_line() { local COLS=$(tput cols); printf "\r" && printf "%${COLS}s\r"; LINE_BREAK="\n"; }
e_set_inline() { LINE_BREAK=""; }
e_spinner() { local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'; while sleep 0.1; do e_reset_line; local temp=${spinstr#?}; printf " ${YELLOW}%s${RESET} ${2}%b${RESET}" "${spinstr:0:1}" "${1}"; local spinstr=$temp${spinstr%"$temp"}; done; }
e_activity() { local MESSAGE="$1"; e_spinner "$MESSAGE" & E_SPINNER_PID=$!; disown $E_SPINNER_PID; }
e_activity_end() { kill $E_SPINNER_PID &> /dev/null; e_reset_line; }
LINE_BREAK="\n"
# // Log functions

[[ "$1" == "source" ]] || e_header "Dotfiles Filipe Kiss"

###########################################
# GENERAL PURPOSE EXPORTED VARS / FUNCTIONS
###########################################

# Where the magic happens.
export DOTFILES=~/.dotfiles

# For testing.
function assert() {
  local success modes equals actual expected
  modes=(e_error e_success); equals=("!=" "=="); expected="$1"; shift
  actual="$("$@")"
  [[ "$actual" == "$expected" ]] && success=1 || success=0
  ${modes[success]} "\"$actual\" ${equals[success]} \"$expected\""
}

# Test if the dotfiles script is currently
function is_dotfiles_running() {
  [[ "$DOTFILES_SCRIPT_RUNNING" ]] || return 1
}

# Test if this script was run via the "dotfiles" bin script (vs. via curl/wget)
function is_dotfiles_bin() {
  [[ "$(basename $0 2>/dev/null)" == dotfiles ]] || return 1
}

# OS detection
function is_osx() {
  [[ "$OSTYPE" =~ ^darwin ]] || return 1
}
function is_ubuntu() {
  [[ "$(cat /etc/issue 2> /dev/null)" =~ Ubuntu ]] || return 1
}

function is_ubuntu_desktop() {
  dpkg -l ubuntu-desktop >/dev/null 2>&1 || return 1
}

function get_os() {
  for os in osx ubuntu ubuntu_desktop; do
    is_$os; [[ $? == ${1:-0} ]] && echo $os
  done
}

# Remove an entry from $PATH
# Based on http://stackoverflow.com/a/2108540/142339
function path_remove() {
  local arg path
  path=":$PATH:"
  for arg in "$@"; do path="${path//:$arg:/:}"; done
  path="${path%:}"
  path="${path#:}"
  echo "$path"
}



# Array mapper. Calls map_fn for each item ($1) and index ($2) in array.
# Usage: array_map array_name map_fn
function array_map() {
  local __arr
  eval __arr=\("\${$1[@]}"\); shift
  for i in "${!__arr[@]}"; do
    "$@" "${__arr[i]}" $i
  done
}

# Print out bash array for debugging purposes
function array_print() { array_map $1 __array_print; }
function __array_print() { echo "$2 <$1>"; }

# Array filter. Calls map_fn for each item ($1) and index ($2) in array.
# Returns filtered array containing array values.
# Usage: array_filter array_name filter_fn
function array_filter() { __array_filter 1 "$@"; }
# Returns filtered array containing array indices.
# Usage: array_filter_i array_name filter_fn
function array_filter_i() { __array_filter 0 "$@"; }

function __array_filter() {
  local __arr __mode __output
  __mode=$1; shift
  eval __arr=\("\${$1[@]}"\); shift
  for i in "${!__arr[@]}"; do
    [[ "$__mode" == 1 ]] && __output="${__arr[i]}" || __output=$i
    "$@" "${__arr[i]}" $i >/dev/null && echo "$__output"
  done
}

# Given strings containing space-delimited words A and B, "setdiff A B" will
# return all words in A that do not exist in B. Arrays in bash are insane
# (and not in a good way).
# From http://stackoverflow.com/a/1617303/142339
function setdiff() {
  local debug skip a b
  if [[ "$1" == 1 ]]; then debug=1; shift; fi
  if [[ "$1" ]]; then
    local setdiff_new setdiff_cur setdiff_out
    setdiff_new=($1); setdiff_cur=($2)
  fi
  setdiff_out=()
  for a in "${setdiff_new[@]}"; do
    skip=
    for b in "${setdiff_cur[@]}"; do
      [[ "$a" == "$b" ]] && skip=1 && break
    done
    [[ "$skip" ]] || setdiff_out=("${setdiff_out[@]}" "$a")
  done
  [[ "$debug" ]] && for a in setdiff_new setdiff_cur setdiff_out; do
    echo "$a ($(eval echo "\${#$a[*]}")) $(eval echo "\${$a[*]}")" 1>&2
  done
  [[ "$1" ]] && echo "${setdiff_out[@]}"
}

# If this file was being sourced, exit now.
[[ "$1" == "source" ]] && return

########################
# INSTALLATION FUNCTIONS
########################
function show_script_header() {
  e_line
  e_line " ██████╗  ██████╗ ████████╗███████╗██╗██╗     ███████╗███████╗ " "${BOLD}${WHITE}"
  e_line " ██╔══██╗██╔═══██╗╚══██╔══╝██╔════╝██║██║     ██╔════╝██╔════╝ " "${BOLD}${WHITE}"
  e_line " ██║  ██║██║   ██║   ██║   █████╗  ██║██║     █████╗  ███████╗ " "${BOLD}${WHITE}"
  e_line " ██║  ██║██║   ██║   ██║   ██╔══╝  ██║██║     ██╔══╝  ╚════██║ " "${BOLD}${WHITE}"
  e_line " ██████╔╝╚██████╔╝   ██║   ██║     ██║███████╗███████╗███████║ " "${BOLD}${WHITE}"
  e_line " ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝╚══════╝╚══════╝╚══════╝ " "${BOLD}${WHITE}"
  e_line
}

function cleanup {
  unset DOTFILES_SCRIPT_RUNNING
}

function show_script_info() {
    DOTFILES_SCRIPT_RUNNING=1
    trap cleanup EXIT
    [[ -d $DOTFILES ]] && local dotfiles_exists="${GREEN}${LOG_STATUS_SUCCESS}${RESET}" || local dotfiles_exists="${RED}${LOG_STATUS_ERROR}${RESET}"
    [[ $(is_dotfiles_bin) ]] && local is_binary="${GREEN}${LOG_STATUS_SUCCESS} Yes${RESET}" || local is_binary="${RED}${LOG_STATUS_ERROR} No${RESET}"
    if [[ -d "${DOTFILES}/.git" ]]; then
      cd $DOTFILES
      show_git_info
    fi
    e_info "Detected OS: $(get_os)"
    e_info "Dotfiles Folder Exists: ${dotfiles_exists} ${DOTFILES}"
    e_info "Is Running as Binary from Path: ${is_binary}"
    e_line
}

function show_git_info() {
  DOTFILES_GIT_INFO_COMMIT=$(git log -n 1 --pretty=format:'%C(yellow)commit:  %h')
  DOTFILES_GIT_INFO_DATE=$(git log -n 1 --pretty=format:'%C(red)date:    %ad' --date=short)
  DOTFILES_GIT_INFO_AUTHOR=$(git log -n 1 --pretty=format:'%C(cyan)author:  %an')
  DOTFILES_GIT_INFO_MESSAGE=$(git log -n 1 --pretty=format:'%C(green)message: %s')

  e_header "Last Commit Info"
  e_info "$DOTFILES_GIT_INFO_COMMIT${LOG_COLOR}"
  e_info "$DOTFILES_GIT_INFO_DATE${LOG_COLOR}"
  e_info "$DOTFILES_GIT_INFO_AUTHOR${LOG_COLOR}"
  e_info "$DOTFILES_GIT_INFO_MESSAGE${LOG_COLOR}"
  e_line
}


function validate_gcc() {
  # Ensure Xcode is installed
  if [[ ! "$(type -P gcc)" ]] && is_osx; then
    e_error "XCode or the Command Line Tools for XCode must be installed first."
    exit 1
  fi
}

function validate_git() {
  # If Git is not installed, install it (Ubuntu only, since Git comes standard
  # with recent XCode or CLT)
  if [[ ! "$(type -P git)" ]] && is_ubuntu; then
    e_info "Installing Git"
    sudo apt-get -qq install git-core
  fi
  # If Git isn't installed by now, something exploded. We gots to quit!
  if [[ ! "$(type -P git)" ]]; then
    e_error "Git should be installed. It isn't. Aborting."
    exit 1
  fi
}

function install_dotfiles() {
  # Initialize.
  local prev_head current_head
  if [[ ! -d "$DOTFILES" ]]; then
    e_info "$DOTFILES doesn't exists."
    mkdir "$DOTFILES"
    git clone --recursive git://github.com/${DOTFILES_GH_USER:-filipekiss}/dotfiles.git --branch="${DOTFILES_GH_BRANCH:-master}" "$DOTFILES" && \
    e_success "${DOTFILES_GH_USER:-filipekiss}/dotfiles cloned"
  elif [[ "$1" != "restart" ]]; then
    prev_head="$(git rev-parse HEAD)"
    e_info "Updating ${DOTFILES_GH_USER:-filipekiss}/dotfiles"
    cd $DOTFILES && \
    e_info "Stashing local changes..." && \
    git add . > /dev/null 2>&1 && \
    git stash > /dev/null 2>&1 && \
    e_info "Pulling updates from origin/${DOTFILES_GH_BRANCH:-master}..." && \
    git pull origin ${DOTFILES_GH_BRANCH:-master} > /dev/null 2>&1 && \
    e_info "Checking out ${DOTFILES_GH_BRANCH:-master}"
    git checkout ${DOTFILES_GH_BRANCH:-master} > /dev/null 2>&1 && \
    git reset --hard origin/${DOTFILES_GH_BRANCH:-master} > /dev/null 2>&1 && \
    e_info "Updating submodules..." && \
    git submodule update --init --recursive > /dev/null 2>&1 && \
    e_info "Returning to your branch"
    git checkout - > /dev/null 2>&1 && \
    e_info "Applying stashed changes..." && \
    git stash pop > /dev/null 2>&1 && \
    e_success "${DOTFILES_GH_USER:-filipekiss}/dotfiles updated"
    if [[ "$1" != "restart" ]]; then
      current_head="$(git rev-parse HEAD)"
      if [[ $current_head != $prev_head ]]; then
        if is_dotfiles_bin; then
          e_info "Changes detected, restarting script"
          exec "$0" restart
        else
          e_info "Changes detected, please re-run script"
          exit
        fi
      fi
    fi
  fi
  cd ${DOTFILES}
}

function update_path() {
  # Add binaries into the path
  [[ -d $DOTFILES/bin ]] && export PATH=$DOTFILES/bin:$PATH
}

function prepare_for_backup() {
  # If backups are needed, this is where they'll go.
  DOTFILES_BACKUP_DIR="${DOTFILES}_backups/$(date "+%Y_%m_%d-%H_%M_%S")/"
  backup=""
  [[ ! -e ${DOTFILES_BACKUP_DIR} ]] && mkdir -p ${DOTFILES_BACKUP_DIR}
}

function show_backup_message() {
  # Alert if backups were made.
  if [[ "$backup" ]]; then
    e_info "Backups were moved to ${BLUE}~/${DOTFILES_BACKUP_DIR#$HOME/}${RESET}"
  fi
}

function link_config() {
  local folders=$(find $DOTFILES/config/* -maxdepth 1 -mindepth 1 -type d)
  local files=$(find $DOTFILES/config/* -maxdepth 1 -mindepth 1 -type f)
  local stow_paths=$(find $DOTFILES/config -maxdepth 1 -mindepth 1 -type d -printf "%f\n")
  for folder in $folders; do
    backup_stuff $folder
    make_folder $folder
  done
  for file in $files; do
    backup_stuff $file
  done
  for stow_path in $stow_paths; do
    do_stow "${stow_path}"
  done;
}

function do_stow() {
  local stow_path="$1"
  if [[ -d "${DOTFILES}/config/${stow_path}" ]]; then
    e_info "Stowing ${YELLOW}${stow_path}${RESET}"
    stow --ignore ".DS_Store" --target="$HOME" --dir="${DOTFILES}/config" $stow_path
  fi
}

function backup_stuff() {
  local DEST
  local TARGET="$1"
  e_info "Preparing ${TARGET}..."
  TARGET=$(basename $TARGET)
  DEST="${HOME}/${TARGET}"
  e_info ${DEST}
  [[ -f ${DEST} ]] && mv "${DEST}" "${DOTFILES_BACKUP_DIR}/${TARGET}" && e_success "${TARGET} backed up" && backup="1"
  [[ -d ${DEST} ]] && mkdir -p ${DOTFILES_BACKUP_DIR}/${TARGET} && mv "${DEST}/*" "${DOTFILES_BACKUP_DIR}/${TARGET}" && e_success "${TARGET} backed up" && backup="1"
}

function make_folder() {
  local FOLDER=$1
  FOLDER=$(basename $FOLDER)
  [[ -e "${HOME}/${FOLDER}" ]] && e_info "${FOLDER} already exists. Skipping..." && return
  mkdir -p "${HOME}/${FOLDER}" && e_success "${FOLDER} created"
}

function setup_git_config() {
  local GIT_USER GIT_EMAIL
  GIT_USER=$(git config --global user.name)
  GIT_EMAIL=$(git config --global user.email)
  [[ ${GIT_USER} == "" ]] && e_set_inline && e_info "What name do you wish to use to sign your commits? " && read GIT_USER
  [[ ${GIT_EMAIL} == "" ]] && e_set_inline && e_info "What e-mail do you wish to use to sign your commits? " && read GIT_EMAIL
  e_reset_line
  if [[ ${GIT_USER:-} != "" ]]; then
    git config --global user.name "${GIT_USER}"
  fi
  if [[ ${GIT_EMAIL:-} != "" ]]; then
    git config --global user.email "${GIT_EMAIL}"
  fi
}


function main() {
  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    e_info "Usage: $(basename "$0")"
    e_info "See the README for documentation."
    e_info "https://github.com/filipekiss/dotfiles"
    e_info "Copyright (c) 2017 Filipe Kiss"
    e_info "Licensed under the MIT license."
    e_line
    show_script_info
  exit; fi

  show_script_header
  show_script_info
  validate_gcc
  validate_git
  update_path
  prepare_for_backup
  install_dotfiles
  link_config
  setup_git_config
  show_backup_message
  # all done!
  e_success "${RESET}All done!"
}

main "$1"
