#!/usr/bin/env zsh
# Log functions
tput sgr0

RED=$(tput setaf 1)
YELLOW=$(tput setaf 3)
GREEN=$(tput setaf 2)
PURPLE=$(tput setaf 5)
BLUE=$(tput setaf 4)
WHITE=$(tput setaf 7)
BOLD=$(tput bold)
RESET=$(tput sgr0)

LOG_STATUS_SUCCESS="✔"
LOG_STATUS_ERROR="✖"
LOG_STATUS_INFO="➜"

e_header()   { e_line && e_line "${1} ==" "${BOLD}" "==" "${BOLD}"; }
e_line() { [[ $LINE_BREAK != "" ]] && LINE_BREAK="\n"; printf "${4} %b${RESET} ${2}%b${RESET}${LINE_BREAK}" "${3}" "${1}"; }
e_success() { e_line "$1" "${GREEN}" "${LOG_STATUS_SUCCESS}" "${GREEN}"; }
e_error() { e_line "$1" "${RED}" "${LOG_STATUS_ERROR}" "${RED}"; }
e_info() { e_line "$1" "" "${LOG_STATUS_INFO}" "${BLUE}"; }
e_reset_line() { local COLS=$(tput cols); printf "\r" && printf "%${COLS}s\r"; LINE_BREAK="\n"; }
e_set_inline() { LINE_BREAK=""; }
e_spinner() { local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'; while sleep 0.1; do e_reset_line; local temp=${spinstr#?}; printf " ${YELLOW}%s${RESET} ${2}%b${RESET}" "${spinstr:0:1}" "${1}"; local spinstr=$temp${spinstr%"$temp"}; done; }
e_activity() { local MESSAGE="$1"; SPINNER_MESSAGE="$1"; e_spinner "$MESSAGE" & E_SPINNER_PID=$! 2> /dev/null; disown $E_SPINNER_PID > /dev/null 2>&1; }
e_activity_end() { kill $E_SPINNER_PID > /dev/null 2>&1; e_reset_line; [[ ! -z $SPINNER_MESSAGE ]] && e_info $SPINNER_MESSAGE; }
LINE_BREAK="\n"
# // Log functions

[[ "$1" == "source" ]] || e_header "Dotfiles Filipe Kiss"

###########################################
# GENERAL PURPOSE EXPORTED VARS / FUNCTIONS
###########################################

# Where the magic happens.
export DOTFILES=~/.dotfiles

#simple function to test if we have access to other functions
function has_dotfiles_function() {
    echo "" || return 1
}

# Test if this script was run via the "dotfiles" bin script (vs. via curl/wget)
function is_dotfiles_bin() {
    [[ $SCRIPT_NAME == $DOTFILES_BINARY_NAME ]] || return 1
}

# OS detection
function is_macos() {
    [[ "$OSTYPE" =~ ^darwin ]] || return 1
}
function is_ubuntu() {
    [[ "$(cat /etc/issue 2> /dev/null)" =~ Ubuntu ]] || return 1
}

function is_ubuntu_desktop() {
    dpkg -l ubuntu-desktop >/dev/null 2>&1 || return 1
}

function get_os() {
    for os in macos ubuntu ubuntu_desktop; do
        is_$os; [[ $? == ${1:-0} ]] && echo $os
    done
}

# Remove an entry from $PATH
# Based on http://stackoverflow.com/a/2108540/142339
function path_remove() {
    local arg path
    path=":$PATH:"
    for arg in "$@"; do path="${path//:$arg:/:}"; done
    path="${path%:}"
    path="${path#:}"
    echo "$path"
}



# Array mapper. Calls map_fn for each item ($1) and index ($2) in array.
# Usage: array_map array_name map_fn
function array_map() {
    local __arr
    eval __arr=\("\${$1[@]}"\); shift
    for i in "${!__arr[@]}"; do
        "$@" "${__arr[i]}" $i
    done
}

# Print out bash array for debugging purposes
function array_print() { array_map $1 __array_print; }
function __array_print() { echo "$2 <$1>"; }

# Array filter. Calls map_fn for each item ($1) and index ($2) in array.
# Returns filtered array containing array values.
# Usage: array_filter array_name filter_fn
function array_filter() { __array_filter 1 "$@"; }
# Returns filtered array containing array indices.
# Usage: array_filter_i array_name filter_fn
function array_filter_i() { __array_filter 0 "$@"; }

function __array_filter() {
    local __arr __mode __output
    __mode=$1; shift
    eval __arr=\("\${$1[@]}"\); shift
    for i in "${!__arr[@]}"; do
        [[ "$__mode" == 1 ]] && __output="${__arr[i]}" || __output=$i
        "$@" "${__arr[i]}" $i >/dev/null && echo "$__output"
    done
}

# Given strings containing space-delimited words A and B, "setdiff A B" will
# return all words in A that do not exist in B. Arrays in bash are insane
# (and not in a good way).
# From http://stackoverflow.com/a/1617303/142339
function setdiff() {
    local debug skip a b
    if [[ "$1" == 1 ]]; then debug=1; shift; fi
    if [[ "$1" ]]; then
        local setdiff_new setdiff_cur setdiff_out
        setdiff_new=($1); setdiff_cur=($2)
    fi
    setdiff_out=()
    for a in "${setdiff_new[@]}"; do
        skip=
        for b in "${setdiff_cur[@]}"; do
            [[ "$a" == "$b" ]] && skip=1 && break
        done
        [[ "$skip" ]] || setdiff_out=("${setdiff_out[@]}" "$a")
    done
    [[ "$debug" ]] && for a in setdiff_new setdiff_cur setdiff_out; do
    echo "$a ($(eval echo "\${#$a[*]}")) $(eval echo "\${$a[*]}")" 1>&2
done
[[ "$1" ]] && echo "${setdiff_out[@]}"
}

# If this file was being sourced, exit now.
[[ "$1" == "source" ]] && return

########################
# INSTALLATION FUNCTIONS
########################
function show_script_header() {
    e_line
    e_line " ██████╗  ██████╗ ████████╗███████╗██╗██╗     ███████╗███████╗ " "${BOLD}${WHITE}"
    e_line " ██╔══██╗██╔═══██╗╚══██╔══╝██╔════╝██║██║     ██╔════╝██╔════╝ " "${BOLD}${WHITE}"
    e_line " ██║  ██║██║   ██║   ██║   █████╗  ██║██║     █████╗  ███████╗ " "${BOLD}${WHITE}"
    e_line " ██║  ██║██║   ██║   ██║   ██╔══╝  ██║██║     ██╔══╝  ╚════██║ " "${BOLD}${WHITE}"
    e_line " ██████╔╝╚██████╔╝   ██║   ██║     ██║███████╗███████╗███████║ " "${BOLD}${WHITE}"
    e_line " ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝╚══════╝╚══════╝╚══════╝ " "${BOLD}${WHITE}"
    e_line
}

function cleanup {
    unset DOTFILES_SCRIPT_RUNNING
}

function show_script_info() {
    DOTFILES_SCRIPT_RUNNING=1
    trap cleanup EXIT INT
    [[ -d $DOTFILES ]] && local dotfiles_exists="${GREEN}${LOG_STATUS_SUCCESS}${RESET}" || local dotfiles_exists="${RED}${LOG_STATUS_ERROR}${RESET}"
    [[ is_dotfiles_bin ]] && local is_binary="${GREEN}${LOG_STATUS_SUCCESS} Yes${RESET}" || local is_binary="${RED}${LOG_STATUS_ERROR} No${RESET}"
    e_info "Detected OS: $(get_os)"
    e_info "Dotfiles Folder Exists: ${dotfiles_exists} ${DOTFILES}"
    e_info "Is Running as Binary from Path: ${is_binary}"
    if [[ -d "${DOTFILES}/.git" ]]; then
        cd $DOTFILES
        show_git_info
    fi
    e_line
}

function show_git_info() {
    DOTFILES_GIT_INFO_COMMIT=$(git log -n 1 --pretty=format:'%C(yellow)commit:  %h')
    DOTFILES_GIT_INFO_DATE=$(git log -n 1 --pretty=format:'%C(red)date:    %ad' --date=short)
    DOTFILES_GIT_INFO_AUTHOR=$(git log -n 1 --pretty=format:'%C(cyan)author:  %an')
    DOTFILES_GIT_INFO_MESSAGE=$(git log -n 1 --pretty=format:'%C(green)message: %s')

    e_header "Last Commit Info"
    e_info "$DOTFILES_GIT_INFO_COMMIT${LOG_COLOR}"
    e_info "$DOTFILES_GIT_INFO_DATE${LOG_COLOR}"
    e_info "$DOTFILES_GIT_INFO_AUTHOR${LOG_COLOR}"
    e_info "$DOTFILES_GIT_INFO_MESSAGE${LOG_COLOR}"
    e_line
}

function run_softwareupdate() {
    cd "$HOME"
    softwareupdate --verbose --install --all
}


function validate_git() {
    # Homebrew or Linuxbrew should be installed at this point, and, consequently, git. If not, try
    # to install it via brew. Otherwise, abort
    if (( ! $+commands[git] )); then
        e_info "Installing Git"
        brew install git
        hash -r
    fi
    # If Git isn't installed by now, something exploded. We gots to quit!
    if (( ! $+commands[git] )); then
        e_error "Git should be installed. It isn't. Aborting."
        exit 1
    fi
}

function validate_stow() {
    if (( ! $+commands[stow] )); then
        e_info "Installing Stow"
        brew install stow
        hash -r
    fi
    # If Stow isn't installed by now, something exploded. We gots to quit!
    if (( ! $+commands[stow] )); then
        e_error "Stow should be installed. It isn't. Aborting."
        exit 1
    fi
}

function validate_homebrew() {
    cd $DOTFILES
    make brew
}

function install_dotfiles() {
    # Initialize.
    local prev_head current_head
    if [[ ! -d "$DOTFILES" ]]; then
        e_info "$DOTFILES doesn't exists."
        mkdir "$DOTFILES"
        git clone --recursive https://github.com/${DOTFILES_GH_USER:-filipekiss}/dotfiles.git --branch="${DOTFILES_GH_BRANCH:-master}" "$DOTFILES" && e_success "${DOTFILES_GH_USER:-filipekiss}/dotfiles cloned"
        if [[ ! -d "$DOTFILES" ]]; then
            e_error "Error when cloning dotfiles repository. Try again"
            exit 1
        fi
        e_info "Since this is the first time you're running this,"
        e_info "this must be run this from path, properly."
        e_info "Please, run the command below"
        update_path()
        e_info "$DOTFILES/bin/$DOTFILES_BINARY_NAME"
        exit 0
    elif [[ "$1" != "restart" ]]; then
        prev_head="$(git rev-parse HEAD)"
        e_info "Updating ${DOTFILES_GH_USER:-filipekiss}/dotfiles"
        cd $DOTFILES && \
            e_info "Stashing local changes..." && \
            git add . && \
            git stash save "dotfiles auto-stash $(date +%s)" && \
            e_info "Pulling updates from origin/${DOTFILES_GH_BRANCH:-master}..." && \
            git pull origin ${DOTFILES_GH_BRANCH:-master} && \
            e_info "Checking out ${DOTFILES_GH_BRANCH:-master}"
        git checkout ${DOTFILES_GH_BRANCH:-master} && \
            git reset --hard origin/${DOTFILES_GH_BRANCH:-master} && \
            e_info "Updating submodules..." && \
            git submodule update --init --recursive && \
            e_info "Returning to your branch"
        git checkout - && \
            e_info "Applying stashed changes..." && \
            git stash pop && \
            e_success "${DOTFILES_GH_USER:-filipekiss}/dotfiles updated"
        if [[ "$1" != "restart" ]]; then
            current_head="$(git rev-parse HEAD)"
            if [[ $current_head != $prev_head ]]; then
                # Remove flags so all install options will run again
                if [[ is_dotfiles_bin ]]; then
                    e_info "Changes detected, restarting script"
                    exec "$DOTFILES_BINARY_NAME" restart
                else
                    e_info "Changes detected, please re-run script"
                    exit
                fi
            fi
        fi
    fi
    cd ${DOTFILES}
}

function update_path() {
    # Add binaries into the path
    [[ -d $DOTFILES/bin ]] && export PATH=$DOTFILES/bin:$PATH
}

function prepare_folders() {
    # If backups are needed, this is where they'll go.
    DOTFILES_BACKUP_DIR="${DOTFILES}_backups/$(date "+%s")"
    backup=""
    [[ ! -e ${DOTFILES_BACKUP_DIR} ]] && mkdir -p ${DOTFILES_BACKUP_DIR}
}

function show_backup_message() {
    # Alert if backups were made.
    if [[ "$backup" ]]; then
        e_info "Backups were moved to ${BLUE}~/${DOTFILES_BACKUP_DIR#$HOME/}${RESET}"
    fi
}

function link_config() {
    IFS=$'\n'
    local files=($(git --work-tree=$DOTFILES --git-dir=$DOTFILES/.git ls-files config/**/*))
    local stow_paths=($(find $DOTFILES/config -maxdepth 1 -mindepth 1 -type d))
    local managed_folders=($(find ~/.dotfiles/config/* -mindepth 1 -type d))
    unset IFS

    for file in $files; do
        file=${file#*/*/}
        backup_stuff $file
    done

    for stow_path in $stow_paths; do
        stow_path=${stow_path#$DOTFILES/config/}
        do_stow "${stow_path}"
    done;
}

function do_stow() {
    local stow_path="$1"
    if [[ -d "${DOTFILES}/config/${stow_path}" ]]; then
        e_info "Stowing ${YELLOW}${stow_path}${RESET}"
        stow --ignore ".DS_Store" --target="$HOME" --dir="${DOTFILES}/config" $stow_path
    fi
}


function backup_stuff() {
    local DEST
    local TARGET="$1"
    e_info "Preparing ${TARGET}..."
    SOURCE="${HOME}/${TARGET}"
    DEST="${DOTFILES_BACKUP_DIR}/${TARGET}"
    if [[ ${TARGET} != $(basename ${TARGET}) ]]; then
        #this config file is located in a subfolder.
        make_folder ${DOTFILES_BACKUP_DIR}/${TARGET%/*}
    fi
    REALPATH=${SOURCE:A}
    [[ -f ${SOURCE} && ${SOURCE} == ${REALPPATH} ]] && mv "${SOURCE}" "${DEST}" && e_success "${TARGET} backed up" && backup="1"
}

function make_folder() {
    local FOLDER=$1
    [[ -e "${FOLDER}" ]] && e_info "${FOLDER} already exists. Skipping..." && return
    mkdir -p "${FOLDER}" && e_success "${FOLDER} created"
}

function setup_git_config() {
    local GIT_USER GIT_EMAIL
    GIT_USER=$(git config -f $HOME/.gitconfig.local user.name)
    GIT_EMAIL=$(git config -f $HOME/.gitconfig.local user.email)
    if [[ ${GIT_USER} == "" ]]; then
        e_set_inline
        e_info "What name do you wish to use to sign your commits? "
        read GIT_USER
    fi
    if [[ ${GIT_EMAIL} == "" ]]; then
      e_set_inline
      e_info "What e-mail do you wish to use to sign your commits? "
      read GIT_EMAIL
    fi
    e_reset_line
    if [[ ${GIT_USER:-} != "" ]]; then
        git config -f $HOME/.gitconfig.local user.name "${GIT_USER}"
    fi
    if [[ ${GIT_EMAIL:-} != "" ]]; then
        git config -f $HOME/.gitconfig.local user.email "${GIT_EMAIL}"
    fi
    cd $DOTFILES
    git remote set-url origin git@github.com:filipekiss/dotfiles.git
}


function install_apps() {
	if [[ -d $DOTFILES ]]; then
		e_info "Installing apps. This may take a while...."
		cd "$DOTFILES" && make
	else
		e_error "There's no $DOTFILES folder"
	fi
}


function main() {
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        e_info "Usage: dotfiles"
        e_info "See the README for documentation."
        e_info "https://github.com/filipekiss/dotfiles"
        e_info "Copyright (c) 2017 Filipe Kiss"
        e_info "Licensed under the MIT license."
        e_line
        show_script_info
        exit
    fi

    # Ask for the administrator password upfront.
    sudo -v

    # Keep-alive: update existing `sudo` time stamp until the script has finished.
    while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &

    if is_macos; then
        run_softwareupdate
    fi

    show_script_header
    show_script_info
    validate_homebrew
    validate_git
    validate_stow
    update_path
    prepare_folders
    install_dotfiles
    link_config
    setup_git_config
    show_backup_message
    install_apps
    # all done!
    e_success "Make sure you change your shell to homebrew's zsh: chsh -s $(brew --prefix)/bin/zsh"
    is_macos && e_success "If it's the first time you're running this, run make macos"
}

SCRIPT_NAME="$(basename $0)"
DOTFILES_BINARY_NAME="dotfiles"
main "$1"
