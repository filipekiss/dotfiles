#!/usr/bin/env zsh
# Log functions
tput sgr0

RED=$(tput setaf 1)
YELLOW=$(tput setaf 3)
GREEN=$(tput setaf 2)
PURPLE=$(tput setaf 5)
BLUE=$(tput setaf 4)
WHITE=$(tput setaf 7)
BOLD=$(tput bold)
RESET=$(tput sgr0)

LOG_STATUS_SUCCESS="✔"
LOG_STATUS_ERROR="✖"
LOG_STATUS_INFO="→"

e_header() {
    print_full_line() {
        local LABEL="$1"
        local CLEAR_LABEL=$(echo $LABEL | sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" | sed "s/\x0f//g" )
        local COLS=$(($2-${#CLEAR_LABEL}-2))
        local space=$(printf ' %.0s' {1..${COLS}})
        e_line "┃ ${LABEL} ${space}┃"
    }



    local COLS=$(tput cols);
    if [[ ${COLS} -gt 80 ]]; then
        COLS=80
    fi
    COLS=$((${COLS}-2))
    local header=$(printf '━%.0s' {1..${COLS}})
    e_line "┏${header}┓"
    local words=($@)
    for word in "${words[@]}"; do
        print_full_line "${word}" "${COLS}"
    done
    e_line "┗${header}┛"
}

e_line() {
    [[ $LINE_BREAK != "" ]] && LINE_BREAK="\n";
    printf "${4}%b${RESET}${2}%b${RESET}${LINE_BREAK}" "${3}" "${1}";
}
e_success() { e_line "$1" "${GREEN}" "${LOG_STATUS_SUCCESS} " "${GREEN}"; }
e_error() { e_line "$1" "${RED}" "${LOG_STATUS_ERROR} " "${RED}"; }
e_info() { e_line "$1" "" "${LOG_STATUS_INFO} " "${BLUE}"; }
e_reset_line() {
    local COLS=$(tput cols);
    printf "\r" && printf "%${COLS}s\r";
    LINE_BREAK="\n";
}
e_set_inline() { LINE_BREAK=""; }
e_spinner() {
  local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
  while sleep 0.1; do
    e_reset_line
    local temp=${spinstr#?}
    printf " ${YELLOW}%s${RESET} ${2}%b${RESET}" "${spinstr:0:1}" "${1}"
    local spinstr=$temp${spinstr%"$temp"}
  done
}

e_activity() {
  local MESSAGE="$1"
  e_spinner "$MESSAGE" &
  E_SPINNER_PID=$!
  disown $E_SPINNER_PID > /dev/null 2>&1 #make sure bash doesn't freak out when we kill the spinner
}

e_activity_end() {
  kill $E_SPINNER_PID &> /dev/null
  e_reset_line
}


LINE_BREAK="\n"
# // Log functions

[[ "$1" == "source" ]] || e_header "Dotfiles Filipe Kiss"

###########################################
# GENERAL PURPOSE EXPORTED VARS / FUNCTIONS
###########################################

# OS detection
function is_macos() {
    [[ "$OSTYPE" =~ ^darwin ]] || return 1
}

function is_linux() {
    [[ "$OSTYPE" =~ ^linux ]] || return 1
}


# simple function to test if we have access to other functions
# I use this in a few scripts, like scripts/python.zsh
function has_dotfiles_function() {
    echo "" || return 1
}
# If this file was being sourced, exit now.
[[ "$1" == "source" ]] && return
#
# Where the magic happens.
DOTFILES="${DOTFILES:-${HOME}/.dotfiles}"

# Test if this script was run via the "dotfiles" bin script (vs. via curl/wget)
function is_dotfiles_bin() {
    [[ -d $DOTFILES && $SCRIPT_NAME == $DOTFILES_BINARY_NAME ]] || return 1
}

function get_os() {
    for os in macos linux; do
        is_$os; [[ $? == ${1:-0} ]] && echo $os
    done
}

function is_dotfiles_running() {
    [[ -e $DOTFILES_BIN_PID ]] || return 1
}

########################
# INSTALLATION FUNCTIONS
########################
function sudo_keepalive() {
    # Ask for the administrator password upfront.
    sudo -v

    # Keep-alive: update existing `sudo` time stamp until the script has finished.
    while true; do sudo -n true; sleep 60; kill -0 "$$" || exit; done 2>/dev/null &
}

function show_script_header() {
    e_line
    e_line " ██████╗  ██████╗ ████████╗███████╗██╗██╗     ███████╗███████╗ " "${BOLD}${WHITE}"
    e_line " ██╔══██╗██╔═══██╗╚══██╔══╝██╔════╝██║██║     ██╔════╝██╔════╝ " "${BOLD}${WHITE}"
    e_line " ██║  ██║██║   ██║   ██║   █████╗  ██║██║     █████╗  ███████╗ " "${BOLD}${WHITE}"
    e_line " ██║  ██║██║   ██║   ██║   ██╔══╝  ██║██║     ██╔══╝  ╚════██║ " "${BOLD}${WHITE}"
    e_line " ██████╔╝╚██████╔╝   ██║   ██║     ██║███████╗███████╗███████║ " "${BOLD}${WHITE}"
    e_line " ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝╚══════╝╚══════╝╚══════╝ " "${BOLD}${WHITE}"
    e_line
}

function zshexit {
    rm -rf $DOTFILES_BIN_PID
}

function show_script_info() {
    [[ -d $DOTFILES ]] && local dotfiles_exists="${GREEN}${LOG_STATUS_SUCCESS}${RESET}" || local dotfiles_exists="${RED}${LOG_STATUS_ERROR}${RESET}"
    [[ is_dotfiles_bin ]] && local is_binary="${GREEN}${LOG_STATUS_SUCCESS} Yes${RESET}" || local is_binary="${RED}${LOG_STATUS_ERROR} No${RESET}"
    e_info "Detected OS: $(get_os)"
    e_info "Dotfiles Folder Exists: ${dotfiles_exists} ${DOTFILES}"
    e_info "Is Running as Binary from Path: ${is_binary}"
    if [[ -d "${DOTFILES}/.git" ]]; then
        cd $DOTFILES
        show_git_info
    fi
    e_line
}

function show_git_info() {
    DOTFILES_GIT_INFO_COMMIT=$(git log -n 1 --pretty=format:'%C(yellow)commit:  %h')
    DOTFILES_GIT_INFO_DATE=$(git log -n 1 --pretty=format:'%C(red)date:    %ad' --date=short)
    DOTFILES_GIT_INFO_AUTHOR=$(git log -n 1 --pretty=format:'%C(cyan)author:  %an')
    DOTFILES_GIT_INFO_MESSAGE=$(git log -n 1 --pretty=format:'%C(green)message: %s')

    e_header "Last Local Commit Info"
    e_info "$DOTFILES_GIT_INFO_COMMIT${LOG_COLOR}"
    e_info "$DOTFILES_GIT_INFO_DATE${LOG_COLOR}"
    e_info "$DOTFILES_GIT_INFO_AUTHOR${LOG_COLOR}"
    e_info "$DOTFILES_GIT_INFO_MESSAGE${LOG_COLOR}"
    e_line
}

function validate_git() {
    # Homebrew should be installed at this point, and, consequently, git. If not, try
    # to install it via brew. Otherwise, abort
    if (( ! $+commands[git] )); then
        e_info "Installing Git"
        brew install git
        hash -r
    fi
    # If Git isn't installed by now, something exploded. We gots to quit!
    if (( ! $+commands[git] )); then
        e_error "Git should be installed. It isn't. Aborting."
        exit 1
    fi
}

function validate_stow() {
    if (( ! $+commands[stow] )); then
        e_info "Installing Stow"
        brew install stow
        hash -r
    fi
    # If Stow isn't installed by now, something exploded. We gots to quit!
    if (( ! $+commands[git] )); then
        e_error "Stow should be installed. It isn't. Aborting."
        exit 1
    fi
}

function validate_homebrew() {
    # Install homebrew
    install_homebrew
    hash -r
}

function install_homebrew() {
    if (( ! $+commands[brew] )) && is_macos; then
        e_info "Installing Homebrew"
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    fi
}

function install_dotfiles() {
    # Initialize.
    local prev_head current_head
    if [[ ! -d "$DOTFILES" ]]; then
        e_info "$DOTFILES doesn't exists."
        mkdir "$DOTFILES"
        git clone --recursive https://github.com/${GITHUB_USER:-filipekiss}/dotfiles.git --branch="${DOTFILES_GH_BRANCH:-master}" "$DOTFILES" && e_success "${GITHUB_USER:-filipekiss}/dotfiles cloned"
        if [[ ! -d "$DOTFILES" ]]; then
            e_error "Error when cloning dotfiles repository. Try again"
            exit 1
        fi
        e_info "Since this is the first time you're running this,"
        e_info "this must be run this from path, properly."
        e_info "Trying to run from path…"
        update_path
        exec "$DOTFILES_BINARY_NAME"
        exit 0
    elif [[ "$1" != "restart" ]]; then
        prev_head="$(git rev-parse HEAD)"
        e_info "Updating ${GITHUB_USER:-filipekiss}/dotfiles"
        cd $DOTFILES && \
            e_info "Stashing local changes..." && \
            git add . && \
            git stash save "dotfiles auto-stash $(date +%s)" && \
            e_info "Pulling updates from origin/${DOTFILES_GH_BRANCH:-master}..." && \
            git pull origin ${DOTFILES_GH_BRANCH:-master} && \
            e_info "Checking out ${DOTFILES_GH_BRANCH:-master}"
        git checkout ${DOTFILES_GH_BRANCH:-master} && \
            git reset --hard origin/${DOTFILES_GH_BRANCH:-master} && \
            e_info "Updating submodules..." && \
            git submodule update --init --remote --recursive && \
            e_info "Returning to your branch"
        git checkout - && \
            e_info "Applying stashed changes..." && \
            git stash pop && \
            e_success "${GITHUB_USER:-filipekiss}/dotfiles updated"
        if [[ "$1" != "restart" ]]; then
            current_head="$(git rev-parse HEAD)"
            if [[ $current_head != $prev_head ]]; then
                # Remove flags so all install options will run again
                if [[ is_dotfiles_bin ]]; then
                    e_info "Changes detected, restarting script"
                    exec "$DOTFILES_BINARY_NAME" restart
                else
                    e_info "Changes detected, please re-run script"
                    exit
                fi
            fi
        fi
    fi
    cd ${DOTFILES}
}

function setup_zshero() {
    curl -fsSL https://raw.githubusercontent.com/filipekiss/zshero/master/zshero-installer | zsh
    source .zshero/init.zsh
    zshero install
}

function update_path() {
    # Add binaries into the path
    export PATH=${HOME}/.dotfiles/bin:$PATH
}

function main() {
    touch $DOTFILES_BIN_PID
    trap zshexit EXIT INT
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        e_info "Usage: dotfiles"
        e_info "See the README for documentation."
        e_info "https://github.com/filipekiss/dotfiles"
        e_info "Copyright (c) 2017-$(date +"%Y") Filipe Kiss"
        e_info "Licensed under the MIT license."
        e_line
        show_script_info
        zshexit
        exit
    fi

    # sudo_keepalive

    show_script_header
    show_script_info
    validate_homebrew
    update_path
    validate_git
    validate_stow
    install_dotfiles
    setup_zshero
    # all done!
    # Change shell if needed
    [[ $SHELL != "$(brew --prefix)/bin/zsh" ]] && e_info "Changing \$SHELL to $(brew --prefix)/bin/zsh"&& exec chsh -s $(brew --prefix)/bin/zsh
    e_success "Don't forget to run ${YELLOW}make all${RESET}"
}

SCRIPT_NAME="$(basename $0)"
DOTFILES_BINARY_NAME="dotfiles"
DOTFILES_BIN_PID="/tmp/dotfiles.pid"
main "$1"
